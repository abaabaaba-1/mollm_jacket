# Write a description for your problem
description: 'This optimization problem is a problem to evaluate stellarator designs for ease of construction and deviation
    from a Quasi-isodynamic (QI) field, is to optimize QI stellarators to be realized using simpler, easier-to-manufacture coils. 
  Because the stellarator symmetric is True, you only need the r_cos and z_sin values.
  This representation defines a toroidal surface (topologically equivalent to a torus) using a two-dimensional Fourier series. 
  The surface maps the poloidal angle theta and the toroidal angle phi to a point in 3D space, described in cylindrical coordinates as (r, phi, z).
  The functions r(theta, phi) and z(theta, phi) are expanded as Fourier series:
  The radial coordinate r(theta, phi) is expressed as a sum of cosine and sine terms with coefficients r_cos[m, n] and r_sin[m, n], 
  where m and n are the poloidal and toroidal mode indices respectively. The argument of each term is (m * theta - NFP * n * phi), 
  where NFP is the number of field periods representing the toroidal symmetry of the surface.
  The vertical coordinate z(theta, phi) is similarly expressed using z_sin[m, n] and z_cos[m, n], but note that the cosine term here 
  uses (m * theta - n * phi) instead of being scaled by NFP.
  The full expressions are:
  r(theta, phi) = sum over m, n of [ r_cos[m, n] * cos(m * theta - NFP * n * phi) + r_sin[m, n] * sin(m * theta - NFP * n * phi) ]
  z(theta, phi) = sum over m, n of [ z_sin[m, n] * sin(m * theta - NFP * n * phi) + z_cos[m, n] * cos(m * theta - n * phi) ]
  These Fourier coefficients are stored in four separate arrays:
  r_cos contains the cosine coefficients for the radial component.
  r_sin contains the sine coefficients for the radial component.
  z_sin contains the sine coefficients for the vertical component.
  z_cos contains the cosine coefficients for the vertical component.
  The indices m and n specify the resolution of the surface in the poloidal and toroidal directions. In this problem, m = 5 and n = 9, 
  meaning the surface includes up to 5 poloidal modes and 9 toroidal modes. Therefore, each coefficient array, including r_cos and z_sin, has shape (5, 9).'

# This part is important, you should set your output format here, and probably give an simple example. The <candidate></candidate> is fixed.
example_output: 'Each output new candidate must start with <candidate> and end with
  </candidate>. Example one output: <candidate>r_cos = np.array([
    [0.50, 0.50,...], ...
  ])
  z_sin = np.array([
    [0.50, 0.51,...], ...
  ])</candidate>'

# Optional mutation and crossover instrution, helpful for better operation, you should start with:"Example operations include: "
mutation_instruction: 'Example operations include:
  1. Largely change the values.
  2. Scale low-order modes:
  Randomly scale the amplitudes of all Fourier modes where the poloidal index is 1 or the toroidal index is 1. This controls the basic elliptical shape of the surface and adjusts its overall radial and vertical size smoothly.
  3. Inject high-frequency noise:
  Introduce small random perturbations into higher-order poloidal and toroidal modes (e.g., modes where both indices are 3 or higher). This adds fine surface ripples or local shape complexities without breaking physical realism.
  4. Apply a toroidal phase twist:
  Apply a small phase rotation to the toroidal modes with index 1. This simulates a slight twisting or rotation of the field shape in the toroidal direction, helping the model explore symmetric variants of the current configuration.
  5. Modulate cross-sectional elongation:
  Increase or decrease the coefficients that correspond to m=2 poloidal modes. This alters the vertical stretching of the surface cross-section, which is closely related to elongation.
  6. Add localized φ-direction perturbation:
  Randomly choose a toroidal index and introduce slight perturbations to all poloidal modes at that index. This simulates a localized deformation or bump on the surface at a specific toroidal slice.
  '
crossover_instruction: 'Example operations include:
  1. Largely exchange the values.
  2. Swap low and high poloidal mode blocks:
  Create a new individual by copying low-poloidal-mode coefficients (e.g., m ≤ 2) from one parent and high-poloidal-mode coefficients (e.g., m > 2) from another. This blends coarse global shape from one parent with finer features from the other.
  3. Weighted averaging of parents:
  Generate a child by taking a weighted average of the Fourier coefficients from both parents, where the weighting is randomly sampled between 30% and 70%. This smooth interpolation allows exploration between known good configurations.
  4. Symmetric-mode-only recombination:
  Combine only the coefficients that preserve stellarator symmetry from both parents, and discard or zero out the others. This ensures that the child retains physically valid symmetric structure.
  5. Top-mode inheritance:
  Identify the three most dominant Fourier modes (by amplitude) from one parent and copy them directly to the child. The remaining coefficients are inherited from the other parent. This preserves the key geometric features of one parent while introducing variability.
  '

# Optional, some extra requirements you would like to achieve
other_requirements: 'constraints are:
  edge rotational transform over number of field period >= 0.25,
  quasi isodynamicity residual (qi) <= -4,
  edge magnetic mirror ratio <= 0.2,
  aspect ratio <= 10
  max elongation <= 5
  violation threshold is 0.01, so only if feasibility value <=0.01 it will give a total score larger than 0, 
  meaning that if all items have 0 total score, priority should be given to improving feasibility.
  '

# The following part are the description of the objectives involved. It is simply consisted of a sentence describe the objective and [optional] normally 
# what operation could cause a rise or drop. 
l_delta_b: The minimum normalized magnetic gradient scale length quantifies how rapidly the magnetic field strength 
  changes near the plasma boundary, normalized by a geometric factor (typically a / NFP, where a is the minor radius and NFP 
  is the number of field periods).
feasibility: The normalized constraint violation is computed as the constraint violation (actual value minus target) divided 
  by the absolute target value, and the feasibility score is the maximum of these normalized violations (with satisfied 
  constraints treated as zero); a design is considered feasible if this score is ≤ 0.01. 